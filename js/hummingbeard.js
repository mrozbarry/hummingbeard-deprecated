
/* Wrap it before you tap it...or something like that */
(function(){
  /* Utility */

  window.HummingBeardUtil = {

    // Merge two objects, similar to $.extend
    object_merge: function( a, b ) {
      //if ( !b ) return a;
      for( var p in b ) {
        try {
          if ( b[p].constructor == Object ) {
            a[p] = object_merge( a[p], b[p] );
          } else {
            a[p] = b[p];
          }
        } catch (e) {
          a[p] = b[p];
        }
      }
      return a;
    },

    // Create a pseudo-global unique identifier
    guid: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });
    },

    has_class: function( element, klass, case_sensitive ) {
      case_sensitive = case_sensitive ? case_sensitive : false;
      if ( !case_sensitive ) klass = klass.toLowerCase();
      var classes = element.className.split(' ');
      for(var c=0; c < classes.length; c++) {
        var test = case_sensitive ? classes[c] : classes[c].toLowerCase();
        if ( test == klass ) return true;
      }
      return false;
    },

    add_class: function( element, klass ) {
      if ( this.has_class( element, klass ) ) return;
      element.className += element.className ? " " + klass : klass;
    },

    remove_class: function( element, klass, case_sensitive ) {
      case_sensitive = case_sensitive ? case_sensitive : false;
      if ( !case_sensitive ) klass = klass.toLowerCase();
      var classes = element.className.split(' ');
      for(var c=0; c < classes.length; c++) {
        var test = case_sensitive ? classes[c] : classes[c].toLowerCase();
        if ( test == klass )
        {
          classes.splice( c, 1 );
          element.className = classes.join(" ");
          return true;
        }
      }
      return false;
    }

  };

  /* HummingBeard */

  /*
   * Hummingbead Message
   * A single message, along with some basic information (when it was placed in the widget, userid, etc.)
   *
   */

  window.HummingBeardMsg = function( parent, options ) {

    /* The parent hummingbeardvo this message is apart of */

    this.hummingbeardvo = parent;

    this.options = HummingBeardUtil.object_merge( {
      type: 'message',
      userid: 'A user',
      userid_suffix: ' says: ',
      status: 'delivered',
      content: '<i>Blank message</i>',
      created_at: new Date(),
      updated_at: new Date(),
      autoscroll: true,
      chat_message_author_class: 'chat_message_author',
      debug: parent.options.debug
    }, options);
    
    this.element = window.document.createElement( 'div' );
    this.element.className = this.options.type;

    if ( this.options.type == 'message' ) {
      var from = window.document.createElement( 'span' );
      from.className = this.options.chat_message_author_class;
      from.innerHTML = this.options.userid + this.options.userid_suffix;
      this.element.appendChild( from );
    }

    var content = window.document.createTextNode( this.options.content );
    this.element.appendChild( content );

    var self = this;

    this.element.addEventListener( "hummingbeard.update_status", function(e){
      // Because IE doesn't believe in standards
      e = e || window.event;

      if ( e.detail.parent.options.debug ) console.log( "update_status", e );

      var now = new Date();
      e.detail.parent.options.updated_at = now;
      var timestr = now.getDay() + "/" + now.getMonth() + "/" + now.getYear() + " " + now.getHours() + ":" + now.getMinutes();
      e.detail.parent.element.setAttribute( "data-status", "Message was " + e.detail.status + " at " + timestr );
    });


    this.update_status = function( delivery_status ) {
      var e = new CustomEvent( "hummingbeard.update_status", {
        'detail': {
          'parent': this,
          'status': delivery_status
        }
      });
      this.element.dispatchEvent( e );
      return true;

    };

    this.scroll_to = function() {
      try {
        this.hummingbeardvo.message_container.scrollTop = this.hummingbeardvo.message_container.scrollHeight;
      } catch(e) {
        this.element.focus();
      }
    }

    this.hummingbeardvo.message_container.appendChild( this.element );
    if ( this.options.autoscroll ) this.scroll_to();
    this.update_status( this.options.status );
  };

  /*
   * Hummingbeard Conversation
   * Stores messages from a particular conversation.
   *
   * Options:
   *  id: A unique identifier for the converation.  [default is a value generated by HummingBeardUtil.guid()]
   *  name: Name of the conversation in its own title bar. [default is 'New Conversation']
   *  header_minimizes: Whether or not clicking on the header minimizes/shrinks the chat window. [default is true]
   *  chat_message_author_class: The class the messages author element uses by default.  [default is 'chat_message_author']
   *  driver: A reference to the driver class, which will then get linked to the conversation and pass information back and forth. [default is null, meaning no driver]
   *  persist_state: Whether or not the conversation gets saved on the clients computer, meaning it remains accessible after page refreshes.  [set automatically by the parent setting]
   *  hide_fn:
   *  show_fn:
   *  close_fn:
   */
  window.HummingBeard = function( options ) {

    /* The parent hummingbeard instance */

    var self = this;

    this.options = HummingBeardUtil.object_merge({
      id: HummingBeardUtil.guid(),
      container: window.document.body,
      name: 'New Conversation',
      connection: null,
      chat_dialog_class: 'chat_dialog',
      header_minimizes: true,
      message_limit: 500,
      message_drop: 250,
      hide_fn: function( conversation ) {
        HummingBeardUtil.remove_class( conversation.element, "visible" );
        HummingBeardUtil.add_class( conversation.element, "hidden" );
      },
      show_fn: function( conversation ) {
        HummingBeardUtil.remove_class( conversation.element, "hidden" );
        HummingBeardUtil.add_class( conversation.element, "visible" );
      },
      close_fn: function( conversation ) {
        console.log( conversation );
        conversation.options.container.removeChild( conversation.element );
      }
    }, options);

    console.log( this.options );

    this.messages = [];

    // Base element
    this.element = window.document.createElement('div');
    this.element.className = this.options.chat_dialog_class + " visible";
    this.element.setAttribute( "id", this.options.id );

    // Close button in header
    var close = window.document.createElement( 'span' );
    close.className = 'close';
    close.innerHTML = '&times;';
    close.onclick = function() {
      self.close();
    };

    this.element.appendChild( close );

    // Header/Conversation title
    this.heading = window.document.createElement( 'span' );
    this.heading.className = 'heading';
    this.heading.innerHTML = this.options.name;
    this.heading.setAttribute( "title", this.options.name );

    if ( this.options.header_minimizes )
    {
      this.heading.onclick = function() {
        if ( HummingBeardUtil.has_class( self.element, "visible" ) ) self.options.hide_fn( self );
        else self.options.show_fn( self );
      }
    }

    this.element.appendChild( this.heading );

    // Container element to put messages into
    this.message_container = window.document.createElement( 'div' );
    this.message_container.className = 'container';
    this.element.appendChild( this.message_container );

    // Input box for chatting
    var input = window.document.createElement( 'input' );
    input.className = 'talk';
    input.setAttribute( 'placeholder', 'Type <enter> to send your message' );
    // Handle pressing enter with text
    input.onkeypress = function( e ) {
      // Because IE doesn't believe in standards
      e = e || window.event;
      // Both keyCode and which are marked as deprecated in MDN, but I don't
      // see any alternatives to get the ascii directly
      var k = e.keyCode ? e.keyCode : e.which;
      var text = this.value;
      if ( text.length )
      {
        if ( k == 13 )
        {
          self.add_message({
            type: 'message',
            id: self.options.id,
            userid: 'Me',
            userid_suffix: ': ',
            status: 'sent',
            content: text,
            chat_message_author_class: 'chat_message_author'
          });
          this.value = "";
        }
      }
    };

    this.element.appendChild( input );

    // Listen for new messages in this conversation
    this.element.addEventListener( "hummingbeard.message", function(e){
      // Because IE doesn't believe in standards
      e = e || window.event;

      if ( e.detail.parent.options.debug ) console.log( "message", e );

      e.detail.parent.messages.push( new HummingBeardMsg( e.detail.parent, e.detail ) );
      if ( e.detail.parent.messages.length >= e.detail.parent.options.message_limit )
      {
        e.detail.parent.message.splice( 0, e.detail.parent.options.message_drop );
      }

    });

    this.element.addEventListener( "hummingbeard.hide", function(e){
      if ( e.detail.parent.options.debug ) console.log( "hide", e );
      e.detail.parent.options.hide_fn( e.detail.parent );
    });

    this.element.addEventListener( "hummingbeard.show", function(e){
      if ( e.detail.parent.options.debug ) console.log( "show", e );
      e.detail.parent.options.show_fn( e.detail.parent );
    });

    this.element.addEventListener( "hummingbeard.close", function(e){
      if ( e.detail.parent.options.debug ) console.log( "close", e );
      e.detail.parent.options.close_fn( e.detail.parent );

      // Do we need to do anything here?  probably not
    });

    this.element.addEventListener( "hummingbeard.rename", function(e){
      if ( e.detail.parent.options.debug ) console.log( "rename", e );
      e.detail.parent.options.close_fn( e.detail.parent );
    });

    this.options.container.appendChild( this.element );

    this.add_message = function( options ) {
      var self = this;
      var e = new CustomEvent( "hummingbeard.message", {
        'detail': HummingBeardUtil.object_merge({
          'parent': self
        }, options)
      });
      this.element.dispatchEvent( e );
    };

    this.hide = function( ) {
      var e = new CustomEvent( "hummingbeard.hide", {
        'detail': {
          'parent': self
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.show = function( ) {
      var e = new CustomEvent( "hummingbeard.show", {
        'detail': {
          'parent': self
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.close = function( ) {
      var e = new CustomEvent( "hummingbeard.close", {
        'detail': {
          'parent': this
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.rename = function( name ) {
      var e = new CustomEvent( "hummingbeard.rename", {
        'detail': {
          'parent': this,
          'name': name
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

  };

  /*
   * HummingBeardConnection
   *
   * Deals with connecting to a service using an account, and relaying messages
   *
   */
  window.HummingBeardConnection = function( driver, options ) {
    
    this.driver = driver;

    this.options = HummingBeardUtil.object_merge( {
      id: HummingBeardUtil.guid(),
      userid: null,
      password: null,
      default_hummingbeard_options: null
    }, options);

    this.chats = [];

    this.relay = function( from, to, message ) {
      console.log( "HummingBeardConnection.relay[stub]", "Please implement this function for correct behaviour" );
    }

    this.chat = function( participants ) {
      if ( !participants ) return null;
      if ( !Array.isArray( participants) ) return null;
      //if ( participants.length == 1 && (participants[0] == this.options.userid ) ) return null;
      var title = "Chatting with " + participants.join(', ');
      var new_chat = {
        hummingbeard: new HummingBeard(HummingBeardUtil.object_merge({
          'userid': this.options.userid,
          'name': title
        }, this.options.default_hummingbeard_options)),
        'participants': participants
      };

      var self = this;
      new_chat.hummingbeard.element.addEventListener( "hummingbeard.message", function(e){
        console.log( e.detail );
        console.log( 'driver message hook', new_chat.participants );
        if ( e.detail.type == 'message' && e.detail.status == 'sent' )
          self.relay( self.options.userid, new_chat.participants, e.detail.content );
      });

      this.chats.push( new_chat );
      return new_chat;
    };

  };

  /*
   * HummingBeardDriver
   *
   * All drivers should inherit this class.  This mostly deals with attaching the driver to a conversation, and managing persistence
   *
   */
  window.HummingBeardDriver = function( options ) {
    
    this.options = HummingBeardUtil.object_merge( {
      /* Normally you'd want things here, like username and password */
      persist_on: [ "navigation", "session_expired" ],
      driver_name: 'unknown_driver',
      driver_authors: ['unknown author'],
      driver_version: 'unknown_version'
    }, options);

    this.connections = [];

    window.document.body.addEventListener( "hummingbeard.navigation", function(e){
      if ( e.detail.parent.options.debug ) console.log( "navigation", e );
      e.detail.parent.options.close_fn( e.detail.parent );
    });

    this.connect_internal = function( options ) {
      console.log( "HummingBeardDriver.connect_internal[stub]", "Please implement this function for correct behaviour" );
    };

    this.connect = function( options ) {
      var new_connection = this.connect_internal( options );
      this.connections.push( new_connection );
      return new_connection;
    };

    this.find_connection = function( userid ) {
      for(var c=0; c < this.connections.length; c++)
        if ( this.connections[c].options.userid == userid ) return this.connections[c];
      return null;
    }

  };

  // Let hummingbeard know if we are navigating away from this page
  window.onbeforeunload = function() {
    var e = new CustomEvent( "hummingbeard.navigation", {
      'detail': {
        'parent': this
      }
    });
    window.document.body.dispatchEvent( e );

    return null;
  }

})();