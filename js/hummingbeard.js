
/* Wrap it before you tap it...or something like that */
(function(){
  /* Utility */

  window.HummingBeardUtil = {

    // Merge two objects, similar to $.extend
    object_merge: function( a, b ) {
      //if ( !b ) return a;
      for( var p in b ) {
        try {
          if ( b[p].constructor == Object ) {
            a[p] = object_merge( a[p], b[p] );
          } else {
            a[p] = b[p];
          }
        } catch (e) {
          a[p] = b[p];
        }
      }
      return a;
    },

    // Create a pseudo-global unique identifier
    guid: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });
    },

    has_class: function( element, klass, case_sensitive ) {
      case_sensitive = case_sensitive ? case_sensitive : false;
      if ( !case_sensitive ) klass = klass.toLowerCase();
      var classes = element.className.split(' ');
      for(var c=0; c < classes.length; c++) {
        var test = case_sensitive ? classes[c] : classes[c].toLowerCase();
        if ( test == klass ) return true;
      }
      return false;
    },

    add_class: function( element, klass ) {
      if ( this.has_class( element, klass ) ) return;
      element.className += element.className ? " " + klass : klass;
    },

    remove_class: function( element, klass, case_sensitive ) {
      case_sensitive = case_sensitive ? case_sensitive : false;
      if ( !case_sensitive ) klass = klass.toLowerCase();
      var classes = element.className.split(' ');
      for(var c=0; c < classes.length; c++) {
        var test = case_sensitive ? classes[c] : classes[c].toLowerCase();
        if ( test == klass )
        {
          classes.splice( c, 1 );
          element.className = classes.join(" ");
          return true;
        }
      }
      return false;
    }

  };

  /* HummingBeard */

  /*
   * Hummingbead Message
   * A single message, along with some basic information (when it was placed in the widget, userid, etc.)
   *
   */

  window.HummingBeardMsg = function( parent, options ) {

    /* The parent hummingbeardvo this message is apart of */

    this.hummingbeardvo = parent;

    this.options = HummingBeardUtil.object_merge( {
      userid: 'A user',
      userid_suffix: ' says:',
      status: 'delivered',
      content: '<i>Blank message</i>',
      created_at: new Date(),
      updated_at: new Date(),
      autoscroll: true,
      chat_message_author_class: 'chat_message_author',
      debug: parent.options.debug
    }, options);
    
    this.userid = userid;
    this.content = content;
    this.status = delivered ? "sent" : "pending";

    this.element = window.document.createElement( 'div' );
    this.element.className = 'message';

    var from = window.document.createElement( 'span' );
    from.className = e.detail.parent.options.chat_message_author_class;
    from.innerHTML = e.detail.from + ':&nbsp;';
    this.element.appendChild( from );

    var content = window.document.createTextNode( e.detail.message );
    this.element.appendChild( content );

    var self = this;

    this.element.addEventListener( "hummingbeard.update_status", function(e){
      // Because IE doesn't believe in standards
      e = e || window.event;

      if ( e.detail.parent.options.debug ) console.log( "update_status", e );

    });


    this.update_status = function( delivery_status ) {
      //
    };

    this.scroll_to = function() {
      try {
        this.hummingbeardvo.message_container.scrollTop = this.hummingbeardvo.message_container.scrollHeight;
      } catch(e) {
        this.element.focus();
      }
    }

    this.hummingbeardvo.message_container.appendChild( this.element );
    if ( this.options.autoscroll ) this.scroll_to();
  };

  /*
   * Hummingbeard Conversation
   * Stores messages from a particular conversation.
   *
   * Options:
   *  id: A unique identifier for the converation.  [default is a value generated by HummingBeardUtil.guid()]
   *  name: Name of the conversation in its own title bar. [default is 'New Conversation']
   *  header_minimizes: Whether or not clicking on the header minimizes/shrinks the chat window. [default is true]
   *  chat_message_author_class: The class the messages author element uses by default.  [default is 'chat_message_author']
   *  driver: A reference to the driver class, which will then get linked to the conversation and pass information back and forth. [default is null, meaning no driver]
   *  persist_state: Whether or not the conversation gets saved on the clients computer, meaning it remains accessible after page refreshes.  [set automatically by the parent setting]
   *  hide_fn:
   *  show_fn:
   *  close_fn:
   */
  window.HummingBeardvo = function( parent, options ) {

    /* The parent hummingbeard instance */

    this.hummingbeard = parent;
    
    var self = this;

    this.options = HummingBeardUtil.object_merge( {
      id: HummingBeardUtil.guid(),
      name: 'New Conversation',
      header_minimizes: true,
      chat_message_author_class: 'chat_message_author',
      driver: null,
      persist_state: parent.options.persist_state,
      hide_fn: function( conversation ) {
        HummingBeardUtil.remove_class( conversation.element, "visible" );
        HummingBeardUtil.add_class( conversation.element, "hidden" );
      },
      show_fn: function( conversation ) {
        HummingBeardUtil.remove_class( conversation.element, "hidden" );
        HummingBeardUtil.add_class( conversation.element, "visible" );
      },
      close_fn: function( conversation ) {
        console.log( conversation );
        conversation.hummingbeard.element.removeChild( conversation.element );
      }
    }, options);

    // Base element
    this.element = window.document.createElement('div');
    this.element.className = parent.options.chat_dialog_class + " visible";
    this.element.setAttribute( "id", this.options.id );

    // Close button in header
    var close = window.document.createElement( 'span' );
    close.className = 'close';
    close.innerHTML = '&times;';
    close.onclick = function() {
      self.close();
    };

    this.element.appendChild( close );

    // Header/Conversation title
    this.heading = window.document.createElement( 'span' );
    this.heading.className = 'heading';
    this.heading.innerHTML = this.options.name;

    if ( this.options.header_minimizes )
    {
      this.heading.onclick = function() {
        if ( HummingBeardUtil.has_class( self.element, "visible" ) ) self.options.hide_fn( self );
        else self.options.show_fn( self );
      }
    }

    this.element.appendChild( this.heading );

    // Container element to put messages into
    this.message_container = window.document.createElement( 'div' );
    this.message_container.className = 'container';
    this.element.appendChild( this.message_container );

    // Input box for chatting
    var input = window.document.createElement( 'input' );
    input.className = 'talk';
    input.setAttribute( 'placeholder', 'Type <enter> to send your message' );
    // Handle pressing enter with text
    input.onkeypress = function( e ) {
      // Because IE doesn't believe in standards
      e = e || window.event;
      // Both keyCode and which are marked as deprecated in MDN, but I don't
      // see any alternatives to get the ascii directly
      var k = e.keyCode ? e.keyCode : e.which;
      var text = this.value;
      if ( text.length )
      {
        if ( k == 13 )
        {
          self.add_message( "Me", text );
          this.value = "";
        }
      }
    };

    this.element.appendChild( input );

    // Listen for adding messages to this conversation
    this.element.addEventListener( "hummingbeard.message", function(e){
      // Because IE doesn't believe in standards
      e = e || window.event;

      if ( e.detail.parent.options.debug ) console.log( "message", e );

      var message = window.document.createElement( 'div' );
      message.className = 'message';

      var from = window.document.createElement( 'span' );
      from.className = e.detail.parent.options.chat_message_author_class;
      from.innerHTML = e.detail.from + ':&nbsp;';
      message.appendChild( from );

      var content = window.document.createTextNode( e.detail.message );
      message.appendChild( content );
      e.detail.parent.message_container.appendChild( message );

      // Attempt to scroll or focus the last message
      try {
        container.scrollTop = e.detail.parent.message_container.scrollHeight;
      } catch(e) {
        message.focus();
      }
    });

    this.element.addEventListener( "hummingbeard.hide", function(e){
      if ( e.detail.parent.options.debug ) console.log( "hide", e );
      e.detail.parent.options.hide_fn( e.detail.parent );
    });

    this.element.addEventListener( "hummingbeard.show", function(e){
      if ( e.detail.parent.options.debug ) console.log( "show", e );
      e.detail.parent.options.show_fn( e.detail.parent );
    });

    this.element.addEventListener( "hummingbeard.close", function(e){
      if ( e.detail.parent.options.debug ) console.log( "close", e );
      e.detail.parent.options.close_fn( e.detail.parent );
    });

    this.element.addEventListener( "hummingbeard.rename", function(e){
      if ( e.detail.parent.options.debug ) console.log( "rename", e );
      e.detail.parent.options.close_fn( e.detail.parent );
    });

    this.hummingbeard.element.appendChild( this.element );

    this.add_message = function( from, content ) {
      var e = new CustomEvent( "hummingbeard.message", {
        'detail': {
          'parent': this,
          'conversation': this,
          'from': from,
          'message': content
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.hide = function( ) {
      var e = new CustomEvent( "hummingbeard.hide", {
        'detail': {
          'parent': self
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.show = function( ) {
      var e = new CustomEvent( "hummingbeard.show", {
        'detail': {
          'parent': self
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.close = function( ) {
      var e = new CustomEvent( "hummingbeard.close", {
        'detail': {
          'parent': this
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

    this.rename = function( name ) {
      var e = new CustomEvent( "hummingbeard.rename", {
        'detail': {
          'parent': this,
          'name': name
        }
      });
      this.element.dispatchEvent( e );
      return true;
    };

  };

  // Main object
  window.HummingBeard = function( options ) {

    /* Merge User and Default Options */
    
    this.options = HummingBeardUtil.object_merge( {
      bosh_service: 'http://localhost:5280/http-bind',
      jabber_host: 'localhost',
      username: 'test@localhost',
      active_chat_limit: 1,
      chat_container_class: 'chat_container',
      chat_dialog_class: 'chat_dialog',
      chat_message_author_class: 'chat_message_author',
      chat_heading_color: 'black',
      debug: false,
      persist_state: true
    }, options );

    /* A nice place to store those beardvos */
    this.beardvos = [];

    /* Initialize the main document object */

    this.element = window.document.createElement('div');
    this.element.className = this.options.chat_container_class;
    
    this.element.addEventListener( "hummingbeard.add_conversation", function(e){
      // Add a new conversation to the element
      if ( e.detail.parent.options.debug ) console.log( "add_conversation", this, e );
      e.detail.parent.beardvos.push( new HummingBeardvo( e.detail.parent, e.detail.options ) );
    }, false);
    
    // Get ride of a conversation (user closes the conversation?)
    this.element.addEventListener( "hummingbeard.remove_conversation", function(e){
      // Remove a conversation from the element
      if ( e.detail.parent.options.debug ) console.log( "remove_conversation", this, e );
      for(var c=0; c < detail.parent.beardvos.lenth; c++) {
        if ( detail.parent.beardvos[c].beardvo.hasAttribute("id") ) {
          if ( detail.parent.beardvos[c].beardvo.getAttribute( "id" ) == id ) {
            var e = new CustomEvent( "hummingbeard.close", { 'detail': { 'parent': detail.parent.beardvos[c] } } );
            this.element.dispatchEvent( e );
            break;
          }
        }
      }
    }, false);
    
    window.document.body.appendChild( this.element );

    // Find an active conversation in the element
    this.find_conversation = function( id ) {
      if ( !id ) return null;
      for(var c=0; c < this.beardvos.length; c++) {
        if ( this.beardvos[c].element.hasAttribute("id") ) {
          if ( this.beardvos[c].element.getAttribute( "id" ) == id ) return this.beardvos[c];
        }
      }
      return null;
    };

    // Add a new conversation to the element
    this.add_conversation = function( options ) {
      options.debug = this.options.debug;
      var e = new CustomEvent( "hummingbeard.add_conversation", { 'detail': { 'parent': this, 'options': options } } );
      this.element.dispatchEvent( e );
    };

    // Add a new conversation to the element
    this.remove_conversation = function( id ) {
      var e = new CustomEvent( "hummingbeard.remove_conversation", { 'detail': { 'parent': this, 'id': id } } );
      this.element.dispatchEvent( e );
    };

  }

})();